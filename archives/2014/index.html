<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014 | best FE</title>
  <meta name="author" content="yu">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="best FE"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="best FE" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">best FE</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2014</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-12-22T02:32:14.000Z"><a href="/2014/12/22/如何使用CORS/">Dec 22 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/12/22/如何使用CORS/">如何使用CORS</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文翻译自<a href="http://www.html5rocks.com/en/tutorials/cors/" target="_blank">html5rocks</a> (需翻墙)</p>
<p>Introduction</p>
<p>APIs are the threads that let you stitch together a rich web experience. But this experience has a hard time translating to the browser, where the options for cross-domain requests are limited to techniques like JSON-P (which has limited use due to security concerns) or setting up a custom proxy (which can be a pain to set up and maintain).</p>
<p>Cross-Origin Resource Sharing (CORS) is a W3C spec that allows cross-domain communication from the browser. By building on top of the XMLHttpRequest object, CORS allows developers to work with the same idioms as same-domain requests.</p>
<h2 id="介绍">介绍</h2>
<p><em>Cross-Origin Resource Sharing(CORS)</em>是W3C的标准，它允许你进行跨域访问。它建立在XMLHttpRequest对象上。</p>
<p>The use-case for CORS is simple. Imagine the site alice.com has some data that the site bob.com wants to access. This type of request traditionally wouldn’t be allowed under the browser’s same origin policy. However, by supporting CORS requests, alice.com can add a few special response headers that allows bob.com to access the data.<br>CORS的应用场景很简单。想象一下alice.com有一些数据bob.com想从中获取。因为同源安全策略的存在，传统上这是不能做到的。然而使用了CORS请求后，alice.com可以添加一些特别的答应头部让bob.com可以访问到alice.com的数据。</p>
<p>As you can see from this example, CORS support requires coordination between both the server and client. Luckily, if you are a client-side developer you are shielded from most of these details. The rest of this article shows how clients can make cross-origin requests, and how servers can configure themselves to support CORS.<br>像你看到的上面的例子一样，使用CORS需要服务端和客户端的合作。文章剩下的部分将告诉你如何在客户端使用CORS发出跨域请求，和如果在配置服务端使它支持CORS.</p>
<p>Making a CORS Request</p>
<h2 id="创建CORS请求">创建CORS请求</h2>
<p>这部分告诉你如何使用java创建跨域请求</p>
<p>This section shows how to make a cross-domain request in JavaScript.<br>Creating the XMLHttpRequest object</p>
<p>CORS is supported in the following browsers:</p>
<p>Chrome 3+<br>Firefox 3.5+<br>Opera 12+<br>Safari 4+<br>Internet Explorer 8+<br>(see the complete list of supported browsers at <a href="http://caniuse.com/#search=cors" target="_blank">http://caniuse.com/#search=cors</a>)<br>Chrome, Firefox, Opera and Safari all use the XMLHttpRequest2 object. Internet Explorer uses the similar XDomainRequest object, which works in much the same way as its XMLHttpRequest counterpart, but adds additional security precautions.</p>
<h3 id="CORS兼容性">CORS兼容性</h3>
<p>Chrome 3+<br>Firefox 3.5+<br>Opera 12+<br>Safari 4+<br>Internet Explorer 8+<br>(see the complete list of supported browsers at <a href="http://caniuse.com/#search=cors" target="_blank">http://caniuse.com/#search=cors</a>)<br>看完整兼容性数据at<a href="http://caniuse.com/#search=cors" target="_blank">http://caniuse.com/#search=cors</a><br>chrome,firefox,opera和safari都是使用XMLHttpRequest2对象。IE使用类似的XDomainRequest对象。</p>
<p>To get started, you will first need to create the appropriate request object. Nicholas Zakas wrote a simple helper method to help sort out the browser differences:<br>To get started,你首先需要创建正确的请求对象。Nicholas Zakas写了一个简单的<a href="http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/" target="_blank">helper method</a>去解决浏览器的兼容问题。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span><span class="params">(method, url)</span> {</span>
    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">if</span>(<span class="string">'withCredentails'</span> <span class="keyword">in</span> xhr) {
        <span class="comment">// 检测XMLHttpRequest对象是否有withCredentails属性</span>
        <span class="comment">// withCredentails只存在于XMLHttpRequest2对象</span>
        xhr.open(method, url, <span class="literal">true</span>);
    }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> XDomainRequest != <span class="string">'undefined'</span>) {
        <span class="comment">// Otherwise, check if XDomainRequest.</span>
        <span class="comment">// XDomainRequest only exists in IE, and is IE's way of making CORS requests.</span>
        <span class="comment">// 否则检测XDomainRequest</span>
        <span class="comment">// XDomainRequest只存在于IE，它是IE创建CORS请求的方式。</span>
        xhr = <span class="keyword">new</span> XDomainRequest();
        xhr.open(method, url);
    }<span class="keyword">else</span> {
        xhr = <span class="literal">null</span>
    };
    <span class="keyword">return</span> xhr;
};

<span class="keyword">var</span> xhr = createCORSRequest(<span class="string">'GET'</span>, url);
<span class="keyword">if</span>(xhr) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'CORS not supported in your browser'</span>);
};
</pre></td></tr></table></figure>

<p>Event handlers</p>
<p>The original XMLHttpRequest object had only one event handler, onreadystatechange, which handled all responses. Although onreadystatechange is still available, XMLHttpRequest2 introduces a bunch of new event handlers. Here is a complete list:</p>
<h3 id="事件处理函数">事件处理函数</h3>
<p>原始的XMLHttpRequeset对象只支持一个事件处理函数-onreadystatechange,它处理所有的回应。虽然onreadystatechange依然可用，XMLHttpRequest2带来了一系列事件处理函数。以下是完整的列表<img src="http://frontend-fucker.qiniudn.com/@/hexo/cors.jpg" alt=""><br>For most cases, you will at the very least want to handle the onload and onerror events:<br>大多数情况下，你会至少使用到onload和onerror事件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> responseText = xhr.responseText;
    console.log(responseText);
    <span class="comment">// process the response.</span>
};
xhr.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'there war an error!'</span>);
};
</pre></td></tr></table></figure>

<p>Browers don’t do a good job of reporting what went wrong when there is an error. For example, Firefox reports a status of 0 and an empty statusText for all errors. Browsers also report an error message to the console log, but this message cannot be accessed from JavaScript. When handling onerror, you will know that an error occurred, but not much else.</p>
<p>withCredentials</p>
<p>Standard CORS requests do not send or set any cookies by default. In order to include cookies as part of the request, you need to set the XMLHttpRequest’s .withCredentials property to true:</p>
<h3 id="withCredentials">withCredentials</h3>
<p>标准的CORS请求默认不会发送或者设置任何cookies。为了将cookies作为请求的一部分，你需要设置XMLHttpRequest的withCredentials属性为true。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xhr.withCredentials = <span class="literal">true</span>;
</pre></td></tr></table></figure>

<p>In order for this to work, the server must also enable credentials by setting the Access-Control-Allow-Credentials response header to “true”. See the server section for details.<br>为了这可以运作起来，服务端必须启动credentials,将Access-Control-Allow-Credentials答应头设为true即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Credentials</span> <span class="subst">=</span> <span class="literal">true</span>;
</pre></td></tr></table></figure>

<p>The .withCredentials property will include any cookies from the remote domain in the request, and it will also set any cookies from the remote domain. Note that these cookies still honor same-origin policies, so your JavaScript code can’t access the cookies from document.cookie or the response headers. They can only be controlled by the remote domain.</p>
<h2 id="Making_the_request">Making the request</h2>
<p>Now that your CORS request is configured, you are ready to make the request. This is done by calling the send() method:</p>
<p><code>xhr.send();</code><br>If the request has a body, it can be specified as an argument to send().</p>
<p>And thats it! Assuming the server is properly configured to respond to CORS requests, your onload handler will fire with the response, just like the standard same-domain XHR you are so familiar with.</p>
<h2 id="发送请求">发送请求</h2>
<p>现在你的CORS请求已经配置好了，你已经准备好去发送请求了。只需要调用<code>send()</code>方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xhr.<span class="keyword">send</span>();
</pre></td></tr></table></figure>

<p>就这么简单！假设你的服务器已经配置好去应答CORS请求了，你的onload事件将会触发，且伴随着response，就想你平时处理同域请求一样。</p>
<h2 id="End-to-End_Example">End-to-End Example</h2>
<p>Here is a full working sample of a CORS request. Run the sample and watch the network requests in the browser’s debugger to see the actual request being made.</p>
<h2 id="完整例子">完整例子</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span><span class="params">(method, url)</span> {</span>
    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">if</span>(<span class="string">'withCredentials'</span> <span class="keyword">in</span> xhr) {
        xhr.open(method, url, <span class="literal">true</span>);
    }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> XDomainRequest != <span class="string">'undefinded'</span>) {
        xhr = <span class="keyword">new</span> XDomainRequest();
        xhr.open(method, url);
    }<span class="keyword">else</span> {
        xhr = <span class="literal">null</span>;
    };
    <span class="keyword">return</span> xhr;
};

<span class="comment">// Helper method to parse the title tag from the response.</span>
<span class="function"><span class="keyword">function</span> <span class="title">getTitle</span><span class="params">(text)</span> {</span>
  <span class="keyword">return</span> text.match(<span class="string">'&lt;title&gt;(.*)?&lt;/title&gt;'</span>)[<span class="number">1</span>];
};

<span class="function"><span class="keyword">function</span> <span class="title">makeCorsRequest</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> url = <span class="string">'http://updates.html5rocks.com'</span>;
    <span class="keyword">var</span> xhr = createCORSRequest(<span class="string">'GET'</span>, url);
    <span class="keyword">if</span>(!xhr) {
        alert(<span class="string">'CORS not supported'</span>);
        <span class="keyword">return</span>;
    };

    xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> text = xhr.responseText;
        <span class="keyword">var</span> title = getTitle(text);
        alert(<span class="string">'Response from CORS request to '</span> + url + <span class="string">': '</span> + title);
    };

    xhr.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert(<span class="string">'Woops, there was an error making the request.'</span>);
    };

    xhr.send();
};
</pre></td></tr></table></figure>

<h2 id="CORS_from_JQuery">CORS from JQuery</h2>
<p>JQuery’s $.ajax() method can be used to make both regular XHR and CORS requests. A few notes about JQuery’s implementation:</p>
<p>JQuery’s CORS implementation doesn’t support IE’s XDomainRequest object. But there are JQuery plugins that enable this. See <a href="http://bugs.jquery.com/ticket/8283" target="_blank">http://bugs.jquery.com/ticket/8283</a> for details.<br>The $.support.cors boolean will be set to true if the browser supports CORS (This returns false in IE, see bullet above). This can be a quick way to check for CORS support.<br>Here’s sample code for making a CORS request with JQuery. The comments give more details on how certain properties interact with CORS.</p>
<h2 id="使用jQuery发送CORS请求">使用jQuery发送CORS请求</h2>
<p>jQuery的$.ajax()可以发送正常的XHR请求和CORS请求。<br>下面说一下使用jquery实现需要注意的地方：<br>jquery实现的CORS不支持IE的XDomainRequest对象。但是你可以找到对应的jquery插件去实现。<br>$.support.cors可以用来检测浏览器的兼容性。<br>下面是用jquery实现CORS的一个实例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre>$.ajax({
    <span class="comment">// The 'type' property sets the HTTP method.</span>
    <span class="comment">// A value of 'PUT' or 'DELETE' will trigger a preflight request.</span>
    type: <span class="string">'GET'</span>,

    <span class="comment">// The URL to make the request to.</span>
    url: <span class="string">'http://updates.html5rocks.com'</span>,

    xhrFields: {
        <span class="comment">// The 'xhrFields' property sets additional fields on the XMLHttpRequest.</span>
        <span class="comment">// This can be used to set the 'withCredentials' property.</span>
        <span class="comment">// Set the value to 'true' if you'd like to pass cookies to the server.</span>
        <span class="comment">// If this is enabled, your server must respond with the header</span>
        <span class="comment">// 'Access-Control-Allow-Credentials: true'.</span>
        <span class="comment">// 如果你想向服务器发送cookies的话，设置withCredentials为true</span>
        <span class="comment">// 而且你的服务器必须返回头部带有'Access-Control-Allow-Credentials:    // true'的回应</span>
        withCredentials: <span class="literal">false</span>
    },

    header: {
        <span class="comment">// 在这里设置自定义的头部</span>
        <span class="comment">// Set any custom headers here.</span>
        <span class="comment">// If you set any non-simple headers, your server must include these</span>
        <span class="comment">// headers in the 'Access-Control-Allow-Headers' response header.</span>
    },

    success: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="comment">// Here's where you handle a successful response.</span>
        <span class="comment">// 这里处理服务器成功返回数据的情况</span>
    },

    error: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="comment">// Here's where you handle an error response.</span>
        <span class="comment">// Note that if the error was due to a CORS issue,</span>
        <span class="comment">// this function will still fire, but there won't be any additional</span>
        <span class="comment">// information about the error.</span>
        <span class="comment">// 这里处理错误的回应</span>
    }
});
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-12-17T09:47:28.000Z"><a href="/2014/12/17/Getting-Started-With-React/">Dec 17 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/12/17/Getting-Started-With-React/">Getting Started With React</a></h1>
  

    </header>
    <div class="entry">
      
        <p>I had been meaning to start playing around with React for quite a while now. There is a lot of buzz around React and I really wanted to see what it was all about. I had looked at a little code written with React and JSX and I was frankly a little taken aback by the syntax. But last week, I was at devLink and I saw a presentation by Jim Cowart on the React framework and several things clicked for me. I’ve started playing around with it this week and I thought I’d write an introductory post to cover what I’ve learned so far.<br>我玩React已经有一段时间了. 最近对于react的讨论真的非常多, 所以我打算写一片文章去介绍一下react.</p>
<h2 id="What_Is_React?">What Is React?</h2>
<p>React is a client-side JavaScript framework created by Facebook and Instagram. React takes a radically different approach to many problems than other client-side frameworks, which makes it interesting to learn.</p>
<p>The React library only focuses on the UI and it has even been implemented as the view layer for many MV* frameworks.</p>
<p>Here are a few things that set React apart.</p>
<h2 id="什么是React?">什么是React?</h2>
<p>React是由<strong>facebook</strong>和<strong>instagram</strong>创建的一个客户端的js框架(译者注:其实很多人并不认为react是一个框架,而是一个js组件)</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-12-09T03:58:36.000Z"><a href="/2014/12/09/difference-between-success()--and-complete()/">Dec 9 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/12/09/difference-between-success()--and-complete()/">difference between .success()  and .complete()</a></h1>
  

    </header>
    <div class="entry">
      
        <p><code>.success()</code> only gets called if your webserver responds with a <code>200 OK</code> HTTP header - basically when everything is fine.</p>
<p>However, <code>.complete()</code> will always get called no matter if the ajax call was successful or not - maybe it outputted errors and returned an error - .complete() will still get called.</p>
<p>It’s worth mentioning that <code>.complete()</code> will get called after <code>.success()</code>gets called - if it matters to you.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-12-08T09:48:18.000Z"><a href="/2014/12/08/初步认识Service-Worker/">Dec 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/12/08/初步认识Service-Worker/">初步认识Service Worker</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Rich offline experiences, periodic background syncs, push notifications— functionality that would normally require a native application—are coming to the web. Service workers provide the technical foundation that all these features will rely on.<br>丰富的线下体验，周期性的后台同步，通知推送（native app的常用功能）即将可以在web上实现了。Service Worker提供了这些功能所需的所有技术基础。</p>
<p>What is a Service Worker?</p>
<p>A service worker is a script that is run by your browser in the background, separate from a web page, opening the door to features which don’t need a web page or user interaction. In the future this will include push messages, background sync, and geofencing, but the first feature it will launch with is the ability to intercept and handle network requests, including programmatically managing a cache of responses.</p>
<h2 id="什么是Service_Worker?">什么是Service Worker?</h2>
<p>service worker是一个运行在浏览器后台的脚本，它和页面分离，它开创了通往不需要页面和UI的道路。<br>service worker包括信息推送，后台更新和地理围栏，但是它第一个会上线的功能是拦截和处理网络请求，包括管理responses。</p>
<p>The reason this is such an exciting API is that it allows you to support offline experiences, giving developers complete control over what exactly that experience is.<br>这个API让人感到兴奋的主要原因是它允许你支持离线体验，让开发者可以完全控制这个体验。</p>
<p>Before service worker there was one other API that would give users an offline experience on the web called App Cache. The major issue with App Cache is the number of gotcha’s that exist as well as the design working particularly well for single page web apps, but not for multi-page sites. Service workers have been designed to avoid these common pain points.<br>在service worker之前，还存在着一个API可以给用户在web上有离线体验，它就是<strong>App Cache</strong>。App Cache最大的问题是它不适合在多页面网站上使用。Service worder就是设计来避免这个问题的。</p>
<p>Things to note about a service worker:</p>
<ul>
<li>It’s a JavaScript Worker, so it can’t access the DOM directly. Instead, a service worker can communicate with the pages it controls by responding to messages sent via the PostMessage interface, and those pages can manipulate the DOM if needed.</li>
<li>Service worker is a programmable network proxy, allowing you to control how network requests from your page are handled.</li>
<li>It will be terminated when not in use, and restarted when it’s next needed, so you cannot rely on global state within a service worker’s <code>onfetch</code> and <code>onmessage</code> handlers. If there is information that you need to persist and reuse across restarts, service workers do have access to the IndexedDB API.</li>
<li>Service workers make extensive use of promises, so if you’re new to promises, then you should stop reading this and check out Jake Archibald’s article.<br>service worker值得注意的一些事情：</li>
<li>它是一个javascript工作线程，所以它不能直接操作DOM。但service worker可以和它控制的页面通信，这些页面可以操作DOM。</li>
<li>Service worker是一个可编程的网络代理，它允许你去控制网络怎么从你的页面请求。</li>
<li>它会在没有在使用时终止，而且会在需要时重启，所以你不能依赖service worder的<code>onfetch</code>和<code>onmessage</code>事件处理函数。如果你有信息需要在重启后保存和重用，service worder倒是可以访问IndexedDB API.</li>
<li>Service worders大量使用<code>promises</code>,所以如果你对promises不熟悉，你不用继续读下去了。请先阅读<a href="http://www.html5rocks.com/en/tutorials/es6/promises/" target="_blank">Jake Archibald’s article</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-11-03T03:41:56.000Z"><a href="/2014/11/03/javascript类和继承分析/">Nov 3 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/11/03/javascript类和继承分析/">javascript类和继承分析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>SPA的增长让javascript架构更加重要。你需要确保你的代码可维护，和避免面条式的代码。<br>很长一段时间以来，一个充满jQuery选择器和事件处理函数的js文件感觉就够用了。但这不是可持续的模式。23世纪的js需要使用更有架构的方法。</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2014/11/03/javascript类和继承分析/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-28T01:43:43.000Z"><a href="/2014/10/28/Web-Components-Template/">Oct 28 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/28/Web-Components-Template/">Web Components Template</a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<p>本文翻译自<a href="http://webcomponents.org/articles/introduction-to-template-element/?utm_source=html5weekly&amp;utm_medium=email" target="_blank">http://webcomponents.org/articles/introduction-to-template-element/?utm_source=html5weekly&amp;utm_medium=email</a></p>
</blockquote>
<h2 id="介绍template元素">介绍template元素</h2>
<p>template元素可以让我们的工作任务分配得更加独立。csser可以更集中在html和css，其他的前端工程师则更集中在逻辑和跟后台的整合上。<br>在这篇文章里，你将可以学到怎样使用这个已经可以兼容chrome, firefox和safari的html5元素。</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2014/10/28/Web-Components-Template/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-22T01:50:19.000Z"><a href="/2014/10/22/useful-javascript-tips,-tricks-and-best-practices/">Oct 22 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/22/useful-javascript-tips,-tricks-and-best-practices/">useful javascript tips, tricks and best practices</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文翻译自<a href="http://modernweb.com/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/" target="_blank">http://modernweb.com/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/</a><br>该文章整理了一些js的常用技巧和最佳实践。</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2014/10/22/useful-javascript-tips,-tricks-and-best-practices/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-15T02:27:58.000Z"><a href="/2014/10/15/如何并发异步获取数据/">Oct 15 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/15/如何并发异步获取数据/">如何并发异步获取数据</a></h1>
  

    </header>
    <div class="entry">
      
        <p>有时我们需要异步获取两三个不同地址的数据，并且在获取数据之后，对这些数据一齐进行处理。下面就介绍一下我们应该怎样应对这种需求并写出性能最高的方案。</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2014/10/15/如何并发异步获取数据/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-08T01:40:27.000Z"><a href="/2014/10/08/3个你应该开始使用的新array方法/">Oct 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/08/3个你应该开始使用的新array方法/">5个你应该开始使用的新array方法</a></h1>
  

    </header>
    <div class="entry">
      
        <p>2009年ES5的发布，给Array增加了一系列的新方法。虽然浏览器对ES5的支持性差，导致这些新方法在实际开发中应用比较少。但仍然有些方法是很值得我们学习的，下面就列出了3个作者觉得是最有用的方法。这3个方法所有的移动浏览器和主流pc浏览器都支持（IE9+）。</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2014/10/08/3个你应该开始使用的新array方法/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-09-03T08:31:17.000Z"><a href="/2014/09/03/如何判断某个元素是否可见？/">Sep 3 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/09/03/如何判断某个元素是否可见？/">如何判断某个元素是否可见？</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="应用场景">应用场景</h2>
<p>有时候我们需要检测某个元素是否可见，然后再作出相应的操作。</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2014/09/03/如何判断某个元素是否可见？/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
    <a href="/archives/2014/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:weiyuxing.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/grunt/">grunt</a><small>2</small></li>
  
    <li><a href="/categories/html5/">html5</a><small>3</small></li>
  
    <li><a href="/categories/javascript/">javascript</a><small>7</small></li>
  
    <li><a href="/categories/react/">react</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Service Worker/">Service Worker</a><small>1</small></li>
  
    <li><a href="/tags/array/">array</a><small>1</small></li>
  
    <li><a href="/tags/grunt配置/">grunt配置</a><small>2</small></li>
  
    <li><a href="/tags/jquery常用插件/">jquery常用插件</a><small>1</small></li>
  
    <li><a href="/tags/js常用片段/">js常用片段</a><small>1</small></li>
  
    <li><a href="/tags/js常见代码片段/">js常见代码片段</a><small>1</small></li>
  
    <li><a href="/tags/js面向对象/">js面向对象</a><small>1</small></li>
  
    <li><a href="/tags/react/">react</a><small>1</small></li>
  
    <li><a href="/tags/template/">template</a><small>1</small></li>
  
    <li><a href="/tags/tips/">tips</a><small>2</small></li>
  
    <li><a href="/tags/异步/">异步</a><small>1</small></li>
  
    <li><a href="/tags/自定义事件，事件命名空间/">自定义事件，事件命名空间</a><small>1</small></li>
  
    <li><a href="/tags/跨域 CORS/">跨域 CORS</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2014/12/22/如何使用CORS/">如何使用CORS</a>
      </li>
    
      <li>
        <a href="/2014/12/17/Getting-Started-With-React/">Getting Started With React</a>
      </li>
    
      <li>
        <a href="/2014/12/09/difference-between-success()--and-complete()/">difference between .success()  and .complete()</a>
      </li>
    
      <li>
        <a href="/2014/12/08/初步认识Service-Worker/">初步认识Service Worker</a>
      </li>
    
      <li>
        <a href="/2014/11/03/javascript类和继承分析/">javascript类和继承分析</a>
      </li>
    
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 yu
  
</div>
<div class="clearfix"></div></footer>
  <script src="//libs.baidu.com/jquery/1.10.2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>